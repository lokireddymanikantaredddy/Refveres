import { SiNextdotjs } from 'react-icons/si';

export const nextjsContent = {
  icon: SiNextdotjs,
  title: 'Next.js',
  color: '#000000',
  description: 'A comprehensive Next.js reference covering pages, routing, data fetching, API routes, styling, optimization, deployment, and advanced patterns.',
  sections: [
    // 1. Next.js Fundamentals
    {
      id: 'fundamentals',
      title: 'Next.js Fundamentals',
      examples: [
        {
          title: 'Pages & File-system Routing',
          code: `// Basic page routing
// pages/index.js → /
export default function Home() {
  return <h1>Home Page</h1>
}

// pages/about.js → /about
export default function About() {
  return <h1>About Page</h1>
}

// Dynamic routes
// pages/posts/[id].js → /posts/1, /posts/2, etc.
import { useRouter } from 'next/router'

export default function Post() {
  const router = useRouter()
  const { id } = router.query

  return <h1>Post: {id}</h1>
}

// Nested routes
// pages/blog/first-post.js → /blog/first-post
export default function FirstPost() {
  return <h1>First Blog Post</h1>
}`,
          explanation: 'Next.js uses file-system based routing. Files in the pages directory become routes. Dynamic routes use [param] syntax. Nested routes are created with subdirectories.'
        },
        {
          title: 'Layout & Custom App',
          code: `// Shared layout component
// components/layout.js
import Head from 'next/head'

export default function Layout({ children }) {
  return (
    <>
      <Head>
        <title>My Site</title>
        <meta name="description" content="Generated by create next app" />
      </Head>
      <main>{children}</main>
    </>
  )
}

// Custom App component (pages/_app.js)
// Wraps all pages
import Layout from '../components/layout'

export default function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  )
}

// Custom Document (pages/_document.js)
// For static HTML customization
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}`,
          explanation: '_app.js initializes pages and is ideal for shared layouts. _document.js customizes the HTML document structure. Layout components help maintain consistent structure across pages.'
        }
      ]
    },
    // 2. Data Fetching
    {
      id: 'data-fetching',
      title: 'Data Fetching',
      examples: [
        {
          title: 'Static Generation (SSG)',
          code: `// pages/posts/[id].js
export async function getStaticPaths() {
  // Fetch all possible paths
  const res = await fetch('https://.../posts')
  const posts = await res.json()

  // Generate paths at build time
  const paths = posts.map((post) => ({
    params: { id: post.id },
  }))

  return { paths, fallback: false }
}

export async function getStaticProps({ params }) {
  // Fetch data for single post
  const res = await fetch(\`https://.../posts/\${params.id}\`)
  const post = await res.json()

  return {
    props: { post },
    // Re-generate page at most once every 10 seconds
    revalidate: 10, // ISR
  }
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  )
}`,
          explanation: 'getStaticProps fetches data at build time for static generation. getStaticPaths specifies dynamic routes to pre-render. revalidate enables Incremental Static Regeneration (ISR).'
        },
        {
          title: 'Server-side Rendering (SSR)',
          code: `// pages/profile.js
export async function getServerSideProps(context) {
  // Context contains request-specific params
  const { req, res, query } = context
  
  // Fetch data on each request
  const user = await getUser(req.cookies.token)

  if (!user) {
    return {
      redirect: {
        destination: '/login',
        permanent: false,
      },
    }
  }

  return {
    props: { user }, // Passed to page component
  }
}

export default function Profile({ user }) {
  return (
    <div>
      <h1>Welcome {user.name}</h1>
    </div>
  )
}`,
          explanation: 'getServerSideProps runs on each request. Useful for personalized data. Can redirect or return notFound. Context provides access to request/response objects.'
        },
        {
          title: 'Client-side Data Fetching',
          code: `// pages/dashboard.js
import { useState, useEffect } from 'react'
import useSWR from 'swr'

const fetcher = (...args) => fetch(...args).then(res => res.json())

export default function Dashboard() {
  const { data, error } = useSWR('/api/stats', fetcher, {
    refreshInterval: 1000
  })

  if (error) return <div>Failed to load</div>
  if (!data) return <div>Loading...</div>

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Visitors: {data.visitors}</p>
    </div>
  )
}`,
          explanation: 'For frequently updating data, use client-side fetching with SWR or similar. SWR provides caching, revalidation, and error handling. Good for dashboards and real-time data.'
        }
      ]
    },
    // 3. API Routes
    {
      id: 'api-routes',
      title: 'API Routes',
      examples: [
        {
          title: 'Basic API Route',
          code: `// pages/api/hello.js
export default function handler(req, res) {
  const { method, query, body } = req

  switch (method) {
    case 'GET':
      res.status(200).json({ name: 'John Doe' })
      break
    case 'POST':
      // Process POST request
      res.status(200).json({ data: body })
      break
    default:
      res.setHeader('Allow', ['GET', 'POST'])
      res.status(405).end(\`Method \${method} Not Allowed\`)
  }
}

// Client-side usage
fetch('/api/hello')
  .then(res => res.json())
  .then(data => console.log(data))`,
          explanation: 'API routes provide backend functionality. Files in pages/api become API endpoints. Handler receives req/res objects similar to Express. Can handle all HTTP methods.'
        },
        {
          title: 'Connect External APIs',
          code: `// pages/api/github.js
import axios from 'axios'

export default async function handler(req, res) {
  const { username } = req.query

  try {
    const response = await axios.get(
      \`https://api.github.com/users/\${username}\`,
      {
        headers: {
          Authorization: \`token \${process.env.GITHUB_TOKEN}\`
        }
      }
    )
    res.status(200).json(response.data)
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
}

// Client-side usage
fetch('/api/github?username=vercel')
  .then(res => res.json())
  .then(data => console.log(data))`,
          explanation: 'API routes can proxy external APIs while hiding tokens. Environment variables keep secrets secure. Good for rate limiting, caching, or transforming API responses.'
        }
      ]
    },
    // 4. Styling
    {
      id: 'styling',
      title: 'Styling',
      examples: [
        {
          title: 'CSS Modules',
          code: `// components/Button.module.css
.primary {
  background: #0070f3;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 4px;
}

/* pages/index.js */
import styles from '../components/Button.module.css'

export default function Home() {
  return (
    <button className={styles.primary}>
      Click me
    </button>
  )
}`,
          explanation: 'CSS Modules provide locally scoped CSS. Files must end with .module.css. Classes are accessed as object properties. Generated unique class names prevent collisions.'
        },
        {
          title: 'Tailwind CSS',
          code: `// Install Tailwind
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init

// tailwind.config.js
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}'
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

// styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

// pages/_app.js
import '../styles/globals.css'

// Usage in components
export default function Home() {
  return (
    <h1 className="text-3xl font-bold text-blue-600">
      Hello Tailwind!
    </h1>
  )
}`,
          explanation: 'Tailwind CSS works well with Next.js. Configure content sources. Import directives in global CSS. Utility classes provide rapid styling without leaving JSX.'
        },
        {
          title: 'Styled JSX',
          code: `export default function Home() {
            return (
              <div>
                <h1>Styled JSX</h1>
                <style jsx>{\`
                  h1 {
                    color: #0070f3;
                    font-size: 2rem;
                  }
                  div {
                    padding: 2rem;
                  }
                \`}</style>
                
                {/* Global styles */}
                <style jsx global>{\`
                  body {
                    margin: 0;
                  }
                \`}</style>
              </div>
            )
          }`,
          explanation: 'Styled JSX is built into Next.js. Provides component-scoped CSS. The global modifier applies styles globally. Works without additional configuration.'
        }
      ]
    },
    // 5. Optimization
    {
      id: 'optimization',
      title: 'Optimization',
      examples: [
        {
          title: 'Image Optimization',
          code: `import Image from 'next/image'

export default function Home() {
  return (
    <div>
      {/* Local image */}
      <Image
        src="/me.png"
        alt="Picture of the author"
        width={500}
        height={500}
        placeholder="blur"
        blurDataURL="data:image/png;base64,..."
      />
      
      {/* Remote image */}
      <Image
        src="https://example.com/photo.jpg"
        alt="Photo"
        width={1200}
        height={800}
        priority // Preload important images
      />
    </div>
  )
}`,
          explanation: 'Next.js Image component automatically optimizes images. Features include lazy loading, size optimization, and modern formats. Requires width/height for layout stability.'
        },
        {
          title: 'Dynamic Imports',
          code: `import dynamic from 'next/dynamic'

// Load component without SSR
const HeavyComponent = dynamic(
  () => import('../components/HeavyComponent'),
  { ssr: false }
)

// With loading state
const WithLoader = dynamic(
  () => import('../components/WithLoader'),
  {
    loading: () => <p>Loading...</p>,
  }
)

export default function Home() {
  return (
    <div>
      <HeavyComponent />
      <WithLoader />
    </div>
  )
}`,
          explanation: 'Dynamic imports help code splitting. Components load only when needed. Useful for heavy dependencies or components not needed for initial render. Can disable SSR.'
        },
        {
          title: 'Performance Monitoring',
          code: `// next.config.js
module.exports = {
  experimental: {
    reactRoot: true,
    concurrentFeatures: true,
  },
}

// pages/_app.js
export function reportWebVitals(metric) {
  // Send to analytics
  console.log(metric) // { id, name, value, delta }
}

// Custom metrics
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'

export function MyApp() {
  useEffect(() => {
    getCLS(console.log)
    getFID(console.log)
    getFCP(console.log)
    getLCP(console.log)
  }, [])
}`,
          explanation: 'Next.js provides performance monitoring tools. reportWebVitals tracks Core Web Vitals. Experimental features enable React 18 concurrent features. Web Vitals API provides detailed metrics.'
        }
      ]
    },
    // 6. Authentication
    {
      id: 'authentication',
      title: 'Authentication',
      examples: [
        {
          title: 'NextAuth.js',
          code: `// pages/api/auth/[...nextauth].js
import NextAuth from 'next-auth'
import Providers from 'next-auth/providers'

export default NextAuth({
  providers: [
    Providers.GitHub({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET,
    }),
  ],
  database: process.env.DATABASE_URL,
  callbacks: {
    async session(session, user) {
      session.user.id = user.id
      return session
    },
  },
})

// pages/index.js
import { signIn, signOut, useSession } from 'next-auth/client'

export default function Home() {
  const [session, loading] = useSession()

  if (loading) return <div>Loading...</div>

  return (
    <div>
      {!session && (
        <button onClick={() => signIn('github')}>
          Sign in with GitHub
        </button>
      )}
      {session && (
        <>
          <p>Welcome {session.user.name}</p>
          <button onClick={signOut}>Sign out</button>
        </>
      )}
    </div>
  )
}`,
          explanation: 'NextAuth.js simplifies authentication. Supports OAuth, email/password, and more. useSession provides session state. Callbacks customize session handling.'
        },
        {
          title: 'Secure API Routes',
          code: `// pages/api/protected.js
import { getSession } from 'next-auth/client'

export default async function handler(req, res) {
  const session = await getSession({ req })

  if (!session) {
    return res.status(401).json({ error: 'Unauthorized' })
  }

  // Access user ID from session
  const userId = session.user.id

  // Process request for authenticated user
  res.status(200).json({ data: 'Protected data' })
}`,
          explanation: 'API routes can be protected by checking sessions. getSession verifies authentication tokens. Session contains user info from the provider. Return 401 for unauthorized requests.'
        }
      ]
    },
    // 7. Deployment
    {
      id: 'deployment',
      title: 'Deployment',
      examples: [
        {
          title: 'Vercel Deployment',
          code: `# Install Vercel CLI
npm install -g vercel

# Deploy to Vercel
vercel

# Environment variables
# Add to .env.local for development
# Add to Vercel project settings for production

# next.config.js for Vercel
module.exports = {
  // Enable ISR
  experimental: {
    isr: true,
  },
  // Set base path if needed
  basePath: '/docs',
}`,
          explanation: 'Vercel is the optimal deployment platform for Next.js. Handles serverless functions, ISR, and edge caching. CLI enables local preview. Environment variables are configured in dashboard.'
        },
        {
          title: 'Static Export',
          code: `// next.config.js
module.exports = {
  output: 'export', // Enable static export
  images: {
    unoptimized: true, // Disable Image Optimization API
  },
}

# Build and export
next build && next export

# Outputs to out directory
# Can be served by any static host

# For hybrid SSG/SSR
// pages/about.js
export async function getStaticProps() {
  return { props: {} }
}

// pages/profile.js 
export async function getServerSideProps() {
  return { props: {} }
}`,
          explanation: 'Static export generates HTML files for fully static sites. output: \'export\' config enables this. API routes and getServerSideProps won\'t work. Hybrid approach mixes SSG and SSR.'
        }
      ]
    },
    // 8. Advanced Patterns
    {
      id: 'advanced',
      title: 'Advanced Patterns',
      examples: [
        {
          title: 'Middleware (Edge Functions)',
          code: `// middleware.js
import { NextResponse } from 'next/server'

export function middleware(req) {
  // Redirect based on cookie
  if (req.cookies['preview-mode']) {
    return NextResponse.rewrite('/preview')
  }

  // Add headers
  const res = NextResponse.next()
  res.headers.set('x-custom-header', 'value')
  return res
}

// Config to match specific paths
export const config = {
  matcher: '/about/:path*',
}

// Advanced usage with TypeScript
import type { NextFetchEvent, NextRequest } from 'next/server'

export function middleware(
  req: NextRequest,
  ev: NextFetchEvent
) {
  // ...
}`,
          explanation: 'Middleware runs before routes. Can rewrite, redirect, or modify requests. Runs on the edge for low latency. Configure matcher to run on specific paths. TypeScript supported.'
        },
        {
          title: 'Internationalization (i18n)',
          code: `// next.config.js
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de'],
    defaultLocale: 'en',
    localeDetection: false,
  },
}

// pages/index.js
import { useRouter } from 'next/router'

export default function Home() {
  const { locale, locales, asPath } = useRouter()

  return (
    <div>
      <h1>Locale: {locale}</h1>
      <ul>
        {locales.map((l) => (
          <li key={l}>
            <Link href={asPath} locale={l}>
              <a>Switch to {l}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  )
}

// API routes support locale
export default function handler(req, res) {
  const { locale } = req.query
  res.json({ locale })
}`,
          explanation: 'Built-in i18n routes support multiple languages. Locale detected automatically or set manually. Links maintain locale context. API routes can access current locale.'
        },
        {
          title: 'Preview Mode',
          code: `// pages/api/preview.js
export default function handler(req, res) {
  // Set preview cookies
  res.setPreviewData({ userId: 123 })
  res.redirect('/preview-page')
}

// pages/api/clear-preview.js
export default function handler(req, res) {
  res.clearPreviewData()
  res.redirect('/')
}

// pages/preview-page.js
export async function getStaticProps(context) {
  // Check for preview mode
  if (context.preview) {
    const data = await getPreviewData(context.previewData.userId)
    return { props: { data } }
  }

  return { props: {} }
}`,
          explanation: 'Preview mode bypasses static generation. Enables draft content viewing. setPreviewData sets cookies. getStaticProps checks context.preview. Clear cookies to exit preview.'
        }
      ]
    }
  ]
};